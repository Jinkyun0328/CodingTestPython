# 게임 맵 최단거리
![images1](https://user-images.githubusercontent.com/123911778/270201069-641d8363-ef9e-48d2-b506-7f9d521c6b15.PNG)
![images2](https://user-images.githubusercontent.com/123911778/270201071-f281efb1-45aa-4695-81c7-97217ed916af.PNG)
![images3](https://user-images.githubusercontent.com/123911778/270201074-84fcbb8b-4ac0-4614-b59b-a127bf424319.PNG)

5x5 크기의 맵에 캐릭터가 (1,1)에 위치하고 있다.
상대팀 진영이 (5,5)이고 이동할 수 부분에 1, 이동할 수 없는 부분에 0이 저장되어 있다.
이때 (1,1)에서 (5,5)로 이동할 수 있는 최소 거리를 반환하라. 

## BFS 원리
그래프 탐색이란 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것을 의미한다.
ex) 특정 도시에서 다른 도시로 갈 수 있는지 없는지, 전자 회로에서 특정 단자와 단자가 서로 연결되어 있는지 확인

BFS(Breadth-First Search) 너비우선탐색이란 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법을 의미힌다.
1. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
2. 깊에 탐색하기 전에 넢게 탐색하는 방법
3. ***두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때*** 사용

## BFS의 특징
1. 직관적이지 않은 면이 있다.
   - BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.
2. BFS는 재귀적으로 동작하지 않는다.
3. 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다.
   - 그렇지 않을 경우 무한 루프에 빠질 수 있다.
4. BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 Queue를 사용한다.

***=> 두 지점 사이의 최단 경로를 찾는 것이므로 BFS를 사용*** 

## 코드 설명
![images4](https://user-images.githubusercontent.com/123911778/270201179-87380c11-59a7-4d19-bd2c-42f0f70c77d1.PNG)
![images5](https://user-images.githubusercontent.com/123911778/270201181-ba3323b3-80fa-494b-a077-02107b67abcb.PNG)

코드상에서 bfs(y, x)를 구현한다.
방문한 노드들을 차례대로 저장한 후 꺼낼 수 있도록 deque을 사용한다.
처음에는 시작노드인 (y, x)와 거리 1을 저장한다.

반복문은 q가 비어있을 때까지 반복 즉 q가 채워져 있으면 반복문을 계속 실행한다.
y, x, distance에 q의 값을 pop한다. (queue에서는 값이 사라짐)
y와 x가 마지막 노드 즉 상대방 진영의 위치와 같다면 현재 distance을 반환한다.
만약 maps[y][x]가 0이라면 길이 아니거나 이미 지나온 길이므로 continue을 사용하여 반복문의 시작으로 넘어간다.
queue에 상하좌우의 좌표와 현재 거리 + 1을 저장한다.

만약 반복문을 모두 실행할 때까지 return이 되지 않았다면 경로가 없는 것이므로 -1을 반환한다.

## 참고
코드를 보면 distance가 1인 시점에서부터 시작하여 queue에는 거리가 작은 지점부터 값이 저장되고
거리가 작은 지점의 값을 먼저 pop하여 조회한다. 이러한 bfs은 최단 경로를 탐색하기에 편리하다.

## 실행결과
![images6](https://user-images.githubusercontent.com/123911778/270201182-1747023d-198e-4c82-bdeb-8ff9e969d64e.PNG)
